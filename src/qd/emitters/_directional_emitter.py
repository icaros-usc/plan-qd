"""Directional emitters

Mutates the prompt in the direction of unexplored solutions in the archive.
"""

import logging
import json

import numpy as np
from ribs.archives import ArchiveBase

from ._llm_emitter import LLMEmitterBase

from typing import List, Dict

logger = logging.getLogger(__name__)

class DirectionalEmitter(LLMEmitterBase):
    """DirectionalEmitter
    """

    def __init__(
        self,
        archive: ArchiveBase,
        result_archive: ArchiveBase,
        solution_dim: int,
        measure_names: list,
        initial_solutions: List[str],
        prompt: Dict[str, str],
        grid_config: Dict,
        mutation_type: List[str],
        batch_size: int,
        gradient_type: str = "none",
        explicit_language: bool = False,
        static: int = 0,
        bounds=None,
        seed=None,
    ):
        self._gradient_type = gradient_type
        self._explicit_language = explicit_language

        LLMEmitterBase.__init__(
            self,
            archive,
            result_archive=result_archive,
            batch_size=batch_size,
            solution_dim=solution_dim,
            measure_names=measure_names,
            initial_solutions=initial_solutions,
            prompt=prompt,
            grid_config=grid_config,
            mutation_type=mutation_type,
            static=static,
            bounds=bounds,
            seed=seed
        )

        self.prospective_solutions = None

    def ask(
        self,
        **kwargs,
    ):
        """Directional Emitter. Uses measure names to mutate prompts in a particular direction.

        NOTE: Assumes that chat_template is False
        """
        if not self._explicit_language:
            self._explicit_language = False

        # construct the number of prompts to mutate based on num to keep static
        num_prompts_to_mutate = self._batch_size * (self._solution_dim - self._static)
        if num_prompts_to_mutate == 0:
            return np.array([], dtype=self.archive.dtypes["solution"])

        # select solutions to mutate
        prospective_solutions = self._random_sample(num_prompts_to_mutate)
        self.prospective_solutions = prospective_solutions

        directional_prompts = []
        self._directions = []

        for sol in prospective_solutions:
            personality = sol[0]

            direction = 2 * self._rng.random((len(self._measure_names),)) - 1
            self._directions.append(direction)

            language_directions = []
            
            for i, d in enumerate(direction):
                if d < 0:
                    language_directions.append("increased " + self._measure_names_as_language[i])
                else:
                    language_directions.append("decreased " + self._measure_names_as_language[i])
            mutation_direction = " and ".join(language_directions)

            # if explicit language, we should use hand-crafted semantics about the measure space to guide the mutation
            # language instructions are specified in the measure config file
            if self._explicit_language:
                additional_info = ""
                for i, m in enumerate(self._measure_names):
                    dir = direction[i]
                    if dir < 0:
                        additional_info += m['description']['neg']
                    else:
                        additional_info += m['description']['pos']

                mutation_direction += additional_info

            mutation_direction_as_language = f"""{self._start_template}

The agent currently has the following personality:

{personality}

Transform the personality to force the agent to play the game optimally with {mutation_direction}. Ensure the new personality is in second person. Keep the new personality brief and to the point. Only return the transformed personality."""

            directional_prompts.append(mutation_direction_as_language)

            if len(directional_prompts) == self._batch_size:
                break

        self._prompts = np.array(directional_prompts, dtype=self.archive.dtypes["solution"])

        return self._prompts

    def tell(self, solution, objective, measures, add_info, **fields):
        """tell the emitter the solution and its objectve values
        
        Args:
            solution (numpy.ndarray): Array of solutions generated by this
                emitter's :meth:`ask()` method.
            objective (numpy.ndarray): 1D array containing the objective
                function value of each solution.
            measures (numpy.ndarray): ``(n, <measure space dimension>)`` array
                with the measure space coordinates of each solution.
            add_info (dict): Data returned from the archive
                :meth:`~ribs.archives.ArchiveBase.add` method.
            fields (keyword arguments): Additional data for each solution. Each
                argument should be an array with batch_size as the first
                dimension.
        """
        logger.info(f"Directional Emitters tell method is not implemented yet.")
        # TODO:
        # if we want to incorporate LMGD ideas here, we can do that. this will take
        # feedback from the results and use that to update the parent mutators for the
        # model. The intended direction of travel is available in self._directions
        pass

    def post_process(
        self,
        results: np.array,
        model=None,
        **kwargs
    ):
        """For directional emitter, each solution is a prompt that has been mutated in a particular direction.
        """

        queries = []

        number_extra_per = 0

        for i, res in enumerate(results):
            # construct the new resultant prompts

            number_extra_per = 0

            for j, goal in enumerate(self._mutation_type):
                # ignore personality for now
                if goal == "personality":
                    continue

                current = self.prospective_solutions[i][j]

                queries.append(f"""Below is information provided to an AI agent playing a cooking game:

'{self._prompt["rules"]}'

The agent is provided with the following mutatable {goal} prompt:

'{current}'

Transform the mutatable {goal} prompt to force the agent to take actions and play the game in a way that is more like the following personality:

'{res}'

Only respond with the new mutatable {goal} prompt.""")

                # increase the number of extra prompt items provided
                number_extra_per += 1


        context_batch = ["You are a helpful assistant"] * len(queries)
        queried_results = model.batch_query(context_batch, queries, temp=1.1)


        final_results = []
        for i, res in enumerate(results):
            section = queried_results[i*number_extra_per:(i+1)*number_extra_per]

            new_entry = [res]
            new_entry.extend(section)

            final_results.append(new_entry)

        # reformat the results back
        return self._reformat_with_static_agents(final_results)